const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const toml = require("@iarna/toml");
const cwd = require("process").cwd();
const glob = require("glob");
const esbuild = require("esbuild");
const { exit } = require("process");

function makeTempDir(){
    if(!fs.existsSync(path.join(cwd, "piochetemp")))
        fs.mkdirSync(path.join(cwd, "piochetemp"), ()=>{});
}

function rmTempDir(){
    if(fs.existsSync("piochetemp"))
        fs.rmSync("piochetemp", {recursive: true});
}

module.exports = async function(logger){
    // Disable console log
    const cslog = console.log;
    console.log = ()=>{};
    console.loggo = cslog;

    try{
        logger.fglog("== Building pioche app ==", "green");

        // Create a temporary build directory
        rmTempDir();
        makeTempDir();

        // Ensure we're in the base directory by checking for package.json
        if(ensureRootDir(logger) === -1) return;

        // Ensure there's a config file
        ensureConfig(logger);

        // Build the pioche.config.js/ts using esbuild
        transpileProject(logger);

        // Retrieve config
        const config = await getConfig(logger);
        if(config === -1) return;

        // Retrieve config imports
        const tbimports = await getConfigImports(logger);

        // Retrieve dotenv
        const dotenv = getDotenv(logger);

        // Discover all controllers
        const controllers = await discoverControllers(logger);
        if(Object.entries({...controllers.workers, ... controllers.durable_objects}).length === 0
            && config.extControllers?.length === 0){
            logger.fgerror("No controllers specified, stopping build");
            return;
        }

        // Find external controllers
        const extControllers = await checkExternalControllers(logger, config.extControllers);

        // Retrieve wrangler.toml
        const wranglerToml = getWranglerToml(logger) || {};
        if(wranglerToml === -1) return;

        // Update our wrangler.toml file
        await updateWranglerToml(logger, wranglerToml, config, dotenv, controllers, extControllers);

        // Generate our entry file
        generateEntry(logger, config, controllers, extControllers, tbimports);

    }catch (e){
        console.error(e);
    }
    // Reenable console log
    console.log = cslog;

    // Delete our temp directory if it exists
    rmTempDir();

};

function ensureRootDir(logger){
    try{
        require(path.join(path.relative(__dirname, cwd), "package.json"));
    } catch {
        logger.fgerror("Run build command in project directory");
        return -1;
    }
}

function ensureConfig(logger) {
    const configExt = ["js", "mjs", "cjs", "ts", "mts", "cts"].filter(ext => 
        fs.existsSync(path.join(cwd, "pioche.config." + ext))
    );
    if(!configExt.length){
        logger.begin("Pioche config not found, creating default");
        const defConfig = {
            extControllers: [],
            prehandlers: [],
            posthandlers: [],
            kv_namespaces: {}
        };
        const contents =
            "// =================================================\n" +
            "// Autogenerated config file\n" +
            "// Use this to configure your workers environment\n"+
            "// Controllers in ../src are automatically included\n" +
            "// =================================================\n\n" +
            "export default " +
            JSON.stringify(defConfig, undefined, 4).replaceAll("\"", "");
        // Write the file
        fs.writeFileSync(path.join(cwd, "/pioche.config.ts"), contents);
        logger.finish();
    }
}

function transpileProject(logger){
    logger.begin("Transpiling if TypeScript");
    const files = [].concat(
        glob.sync(cwd + "/src/**/*.js", {}),
        glob.sync(cwd + "/src/**/*.cjs", {}),
        glob.sync(cwd + "/src/**/*.mjs", {}),
        glob.sync(cwd + "/src/**/*.jsx", {}),
        glob.sync(cwd + "/src/**/*.ts", {}),
        glob.sync(cwd + "/src/**/*.mts", {}),
        glob.sync(cwd + "/src/**/*.cts", {}),
        glob.sync(cwd + "/src/**/*.tsx", {})
    ).filter((name) => path.basename(name) !== "entry.ts");
    const configExt = ["js", "mjs", "cjs", "ts", "mts", "cts"].filter(ext => 
        fs.existsSync(path.join(cwd, "pioche.config." + ext))
    )[0]; // We already ensured that this exists
    esbuild.buildSync({
        entryPoints: [...files, path.join(cwd, "pioche.config." + configExt)],
        outdir: path.join(cwd, "piochetemp"),
        logLevel: "silent",
        format: "esm",
        bundle: true
    });
    logger.finish();
}

async function getConfig(logger){
    logger.begin("Opening pioche config");
    try{
        const config = await import(
            path.join(path.relative(__dirname, cwd), "piochetemp/pioche.config.js")
        ).then((m) => m.default);
        logger.finish();
        return config;
    } catch (e) {
        logger.fail("Unable to parse pioche config");
        console.error(e);
        return -1;
    }
}

async function checkExternalControllers(logger, extControllers){
    logger.begin("Incorporating external controllers");
    const controllers = {workers: [], durable_objects: []};
    for(const value of extControllers || []){
        checkPotentialController(value, (name) => {
            controllers.durable_objects.push(name);
        }, (name) => {
            controllers.workers.push(name);
        });
    }
    logger.finish();
    return controllers;
}

async function getConfigImports(logger){
    logger.begin("Copying imports from pioche.config.js");
    const contents = fs.readFileSync(path.join(cwd, "piochetemp/pioche.config.js"), "utf8");
    // Find the export default statement
    const importreqs = [];
    let start = undefined;
    // Find all import statements
    // Import statements start with "import" and end with ;
    // ; is guaranteed due to esbuild!
    [...contents].forEach((c, i) => {
        if(contents.slice(i, i+6) === "import"){
            start = i;
        }
        if(c === ";" && start !== undefined){
            importreqs.push(contents.slice(start, i+1));
            start = undefined;
        }
    });
    logger.finish();
    // Warn for the use of require statements
    contents.split("\n").forEach((lin) => {
        if(lin.includes(" require("))
            logger.fgerror("Use of require() statements not currently allowed");
    });
    return importreqs;
}

function getDotenv(logger){
    logger.begin("Opening and parsing .env");
    const dotenv = require("dotenv").config().parsed;
    if(!dotenv){
        logger.info("Generating new .env with secure JWT secret");
        const key = crypto.randomBytes(32).toString("hex");
        const contents =
            "# =============================================\n" +
            "# Define environment variables here\n" +
            "# Never commit your .env file\n"+
            "# =============================================\n\n"+
            `JWT_SECRET=${key}`;
        // Write the file
        fs.writeFileSync(path.join(cwd, "/.env"), contents);
        logger.finish();
        return {JWT_SECRET: key};
    }else{
        logger.finish();
        return dotenv;
    }
}

async function discoverControllers(logger){
    logger.begin("Discovering controllers");
    const files = [].concat(
        glob.sync(cwd + "/piochetemp/src/**/*.js", {}),
        glob.sync(cwd + "/piochetemp/src/**/*.mjs", {})
    );
    const controllers = {workers: {}, durable_objects: {}};
    // Check that we have something to process
    if(!files.length){
        logger.info("No js/ts code found in src/ directory");
        return controllers;
    }
    logger.finish();
    // Iterate over the files discovering exports
    for(const filename of files){
        logger.fgwrite("    > FILE: " + path.basename(filename), "yellow");
        const exports = await getExports(filename, logger);
        for(const [, value] of Object.entries(exports || {})){
            const importpath = path.relative(path.join(cwd, "src"), filename);
            checkPotentialController(value, (name) => {
                controllers.durable_objects[name] = importpath;
            }, (name) => {
                controllers.workers[name] = importpath;
            });
        }
    }
    return controllers;
}

async function getExports(filename, logger){
    try{
        // Try to import it as a module
        logger.fgwrite(" > importing as ES6", "yellow");
        const exports = await import(filename);
        logger.fglog(" > success", "green");
        return exports;
    } catch (e) {
        logger.fglog(" > failed", "red\n");
        console.error(e);
    }
}

function checkPotentialController(value, doCallback, workerCallback){
    let proto = value;
    const name = proto.name;
    while(proto.name !== undefined){
        if(proto.name === "DurableObjectController"){
            // Don't care where it comes from as long as it's exported
            doCallback?.(name);
            break;
        }
        if(proto.name === "WorkerController"){
            // Don't care where it comes from as long as it's exported
            workerCallback?.(name);
            break;
        }
        proto = proto.__proto__;
    }
}

function getWranglerToml(logger){
    logger.begin("Opening and parsing wrangler.toml");
    try{
        const tomlRaw = fs.readFileSync(path.join(cwd, "wrangler.toml"), "utf8");
        if(tomlRaw){
            try{
                const wranglerToml = toml.parse(tomlRaw);
                logger.finish();
                return wranglerToml;
            } catch (e) {
                logger.error("Error parsing wrangler.toml on line " + e.line + ", column " +
                e.column + ": " + e.message);
                return -1;
            }
        }
    } catch {
        logger.info("No wrangler.toml found, generating");
        return {};
    }
}

/**
 * Creates an updated wrangler.toml with migrations, bindings, and build command set
 * @param contents Contents of the original wrangler.toml
 * @param config pioche.config config file
 */
async function updateWranglerToml(logger, contents, config, dotenv, controllers, extControllers){
    logger.begin("Generating wrangler.toml");
    const header =
        "# =============================================================================\n" +
        "# Required for workers runtime, never commit this file\n" +
        "# durable_objects, kv_namespaces, migrations, build, and vars autogenerated\n" +
        "# =============================================================================\n\n";
    // Set vars to our .env entries
    contents.vars = dotenv;

    // Set kv_namespaces to our kv_namespaces
    contents.kv_namespaces = [];
    Object.entries(config.kv_namespaces || []).forEach(([binding, id]) => {
        contents.kv_namespaces.push({binding: binding, id: id});
    });

    // Set Durable Object Bindings
    const oldDOs = contents.durable_objects?.bindings.map((e)=>e.name);
    contents.durable_objects = {
        bindings: [
            ...Object.entries(controllers.durable_objects).map(([e]) => e),
            ...extControllers.durable_objects
        ].map((name) => {
            return {
                name: name,
                class_name: name
            };
        }
    )};
    const newDOs = contents.durable_objects?.bindings.map((e)=>e.name);

    // FWD: Migrations compare oldDOs and newDOs
    if(!contents.migrations) contents.migrations = [];
    const tag = `automigrate-${contents.migrations.length + 1}`;
    // Generate the migration
    const migration = await migrationPrompt(logger, tag, oldDOs, newDOs);
    if(migration){
        contents.migrations.push(migration);
    }

    // Set the build command
    contents.build = {
        command: "npm run build",
        cwd: "./",
        watch_dir: "src"
    };

    // Set the entry point
    contents.main = "src/entry.ts";
    contents.tsconfig = "./tsconfig.json";
    // Set but don't override the name, workers_dev, minify, & compat date
    if(!contents.name) contents.name = path.relative(path.join(cwd, ".."), cwd);
    if(contents.workers_dev === undefined) contents.workers_dev = true;
    if(contents.minify === undefined) contents.minify = true;
    const datestr = (new Date()).toISOString().slice(0, 10);
    if(!contents.compatibility_date) contents.compatibility_date = datestr;
    // Node compat is require
    contents.node_compat = true;

    // Prompt for account_id, allow non-entry
    if(!contents.account_id){
        const readline = require("readline").createInterface({
            input: process.stdin,
            output: process.stdout
        });
        let lockres = undefined;
        const lock = new Promise((resolve)=>{lockres = resolve;});
        readline.question("  > Enter CF account_id or enter to skip: ", aid => {
            if(aid) contents.account_id = aid;
            readline.close();
            lockres();
        });
        await lock;
        logger.fgwrite("\033[1A"); // Move the stdin cursor back up one line
    }

    // Don't write out empty arrays
    if(!contents.kv_namespaces.length) delete contents.kv_namespaces;
    if(!contents.migrations.length) delete contents.migrations;
    if(!contents.durable_objects.bindings.length) delete contents.durable_objects;

    // Write out the new file
    const tomlOutputString = header + toml.stringify(contents);
    fs.writeFileSync(path.join(cwd, "wrangler.toml"), tomlOutputString);
    logger.finish();
}

async function migrationPrompt(logger, tag, oldDO, newDO){
    // First check if they're the same
    const removed = oldDO?.filter((e) => !newDO?.includes(e)) || [];
    const added = newDO?.filter((e) => !oldDO?.includes(e)) || [];
    const renamed = []; // [{from, to}]
    // We'll need to prompt for renames
    if(removed.length && added.length){
        logger.info("Durable Object changes require input");
        const prompt = require("inquirer").prompt;
        const ask = async (index) => {
            return prompt([
                {
                    type: "list",
                    name: "choice",
                    message: `Rename or delete ${removed[index]}`,
                    choices: added.concat("DELETE")
                }
                ]).then(a => a.choice).then(choice => {
                    if(choice !== "DELETE"){
                        // Remove the chosen item from added
                        added.splice(added.indexOf(choice), 1);
                        // Added the new entry to renamed
                        renamed.push({from: removed[index], to: choice});
                        // Remove the item from removed
                        delete removed[index];
                    }
                });
        };
        for(let idx = 0; removed.length && added.length && idx < removed.length; idx++)
            await ask(idx);
        const conf = await prompt([{
            type: "confirm",
            message: "Are all above choices correct?",
            name: "conf",
            default: false
        }]).then(a => a.conf);
        if(!conf){
            logger.fail("Exiting due to incorrect choices, restart build to fix");
            exit(1);
        }
    }
    if(added.length || removed.length || renamed.length)
        return {
            tag: tag,
            new_classes: added,
            deleted_classes: removed,
            renamed_classes: renamed
        };
}

function generateEntry(logger, config, controllers, extControllers, tbimports){
    logger.begin("Generating entry file");
    let contents = "";
    contents +=
        "// ===================================================\n" +
        "// Created automatically, edits won't have any effect\n" +
        "// ===================================================\n\n" +
        "// Required imports from pioche\n" +
        "import { DefaultHandlers, Router } from \"pioche\";\n\n";
    
    
    // Bring in imports from pioche.config
    if(tbimports.length){
        contents += "// The following were brought in from pioche.config.ts/js\n" +
            tbimports.join("\n").replaceAll("src/", "") + "\n\n";
    }

    // Use our compiled controller list to bring in local controllers
    contents += "// Import all discovered controllers\n" + [
            ...Object.entries(controllers.workers),
            ...Object.entries(controllers.durable_objects)
        ].map(([name, loc]) => {
            const extlen = path.extname(loc).length;
            return `import { ${name} } from "./${loc.slice(0, loc.length - extlen).replace("../piochetemp/src/", "")}"`;
        }).join(";\n") + ";\n\n";

    // Exporting all Durable Objects
    contents += "// Export DurableObjectControllers\n" + 
        "export { " + [
        ...Object.entries(controllers.durable_objects).map(([n])=>n),
        ...extControllers.durable_objects
    ].join(", ") + " };\n\n";


    // List all controllers to avoid tree shaking
    contents += "// Prevent tree shaking and map to preminified names\n" +
        "Router.setBindings([\n" + [
            ...Object.entries(controllers.workers).map(([n])=>n),
            ...Object.entries(controllers.durable_objects).map(([n])=>n),
            ...extControllers.workers,
            ...extControllers.durable_objects
        ].map(c => `    [${c}, "${c}"]`).join(",\n") + "\n]);\n\n";

    // Router.useBefore all of the prehandlers
    if(config.prehandlers.length){
        contents += "// Add all configged prehandlers to the Router\n" + 
        config.prehandlers?.map(
            (ph) => `Router.useBefore(${ph.name})`
        ).join(";\n") + ";\n\n";
    }
    
    // Router.useAfter all of the posthandlers
    if(config.posthandlers.length){
        contents += "// Add all configged postHandlers to the Router\n" + 
        config.posthandlers.map(
            (ph) => `Router.useAfter(${ph.name})`
        ).join(";\n") + ";\n\n";
    }

    contents += "export default DefaultHandlers;\n";
    // Write the file
    fs.writeFileSync(path.join(cwd, "src/entry.ts"), contents);
    logger.finish();
}