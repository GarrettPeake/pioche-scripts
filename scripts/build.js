const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const toml = require("@iarna/toml");
const cwd = require("process").cwd();
const glob = require("glob");
const esbuild = require("esbuild");

function makeTempDir(){
    if(!fs.existsSync(path.join(cwd, "piochetemp")))
        fs.mkdirSync(path.join(cwd, "piochetemp"), ()=>{});
}

function rmTempDir(){
    if(fs.existsSync("piochetemp"))
        fs.rmSync("piochetemp", {recursive: true});
}

module.exports = async function(logger){
    // Disable console log
    const cslog = console.log;
    console.log = ()=>{};

    try{
        logger.fglog("== Building pioche app ==", "green");


        // Create a temporary build directory
        makeTempDir();

        // Ensure we're in the base directory by checking for package.json
        try{
            require(path.join(path.relative(__dirname, cwd), "package.json"));
        } catch {
            logger.fgerror("Run build command in project directory");
            return;
        }

        // Build the pioche.config.js/ts using esbuild
        buildConfig(logger);

        // Retrieve config
        let config = await getConfig(logger);
        if(!config){
            config = createDefaultConfig(logger);
            buildConfig();
        }
        if(config === -1) return;

        // Retrieve config imports
        const tbimports = await getConfigImports(logger);

        // Retrieve dotenv
        const dotenv = getDotenv(logger) || createDefaultDotenv(logger);

        // Discover all controllers
        const controllers = await discoverControllers(logger);
        if(Object.entries({...controllers.workers, ... controllers.durable_objects}).length === 0
            && config.extControllers?.length === 0){
            logger.fgerror("No controllers specified, stopping build");
            return;
        }

        // Find external controllers
        const extControllers = await checkExternalControllers(logger, config.extControllers);

        // Retrieve wrangler.toml
        const wranglerToml = getWranglerToml(logger) || {};
        if(wranglerToml === -1) return;

        // Update our wrangler.toml file
        await updateWranglerToml(logger, wranglerToml, config, dotenv, controllers, extControllers);

        // Generate our entry file
        generateEntry(logger, config, controllers, extControllers, tbimports);

    }catch (e){
        console.error(e);
    }
    // Reenable console log
    console.log = cslog;

    // Delete our temp directory if it exists
    rmTempDir();

};

function buildConfig(){
    // Generate both regular and bundles
    if(fs.existsSync(path.join(cwd, "pioche.config.js"))){
        esbuild.buildSync({
            entryPoints: ["pioche.config.js"],
            outfile: path.join(cwd, "piochetemp/pioche.config.mjs"),
            logLevel: "silent",
            format: "esm"
        });
        esbuild.buildSync({
            entryPoints: ["pioche.config.js"],
            outfile: path.join(cwd, "piochetemp/pioche.config.bundle.mjs"),
            logLevel: "silent",
            bundle: true,
            format: "esm"
        });
    }
    if(fs.existsSync(path.join(cwd, "pioche.config.ts"))){
        esbuild.buildSync({
            entryPoints: ["pioche.config.ts"],
            outfile: path.join(cwd, "piochetemp/pioche.config.mjs"),
            logLevel: "silent",
            format: "esm"
        });
        esbuild.buildSync({
            entryPoints: ["pioche.config.ts"],
            outfile: path.join(cwd, "piochetemp/pioche.config.bundle.mjs"),
            logLevel: "silent",
            bundle: true,
            format: "esm"
        });
    }
    return 1;
}

async function getConfig(logger){
    logger.begin("Opening pioche config");
    try{
        const config = await import(
            path.join(path.relative(__dirname, cwd), "piochetemp/pioche.config.bundle.mjs")
        ).then((m) => m.default);
        logger.finish();
        return config;
    } catch (e) {
        if(fs.existsSync(path.join(cwd, "pioche.config.js")) ||
        fs.existsSync(path.join(cwd, "pioche.config.ts"))){
            logger.fail("Unable to parse pioche.config.js");
            console.log(e);
            return -1;
        }
        else
            logger.info("Unable to locate pioche.config.js");
    }
}

function createDefaultConfig(logger) {
    logger.begin("Creating default pioche config file");
    const defConfig = {
        extControllers: [],
        prehandlers: [],
        posthandlers: [],
        kv_namespaces: {},
    };
    const contents =
        "// =================================================\n" +
        "// Autogenerated config file\n" +
        "// Use this to configure your workers environment\n"+
        "// Controllers in ../src are automatically included\n" +
        "// =================================================\n\n" +
        "export default " +
        JSON.stringify(defConfig, undefined, 4).replaceAll("\"", "");
    // Write the file
    fs.writeFileSync(path.join(cwd, "/pioche.config.ts"), contents);
    logger.finish();
    return defConfig;
}

async function checkExternalControllers(logger, extControllers){
    logger.begin("Sorting imported DO controllers");
    const controllers = {workers: [], durable_objects: []};
    for(const value of extControllers || []){
        checkPotentialController(value, (name) => {
            controllers.durable_objects.push(name);
        }, (name) => {
            controllers.workers.push(name);
        });
    }
    logger.finish();
    return controllers;
}

async function getConfigImports(logger){
    logger.begin("Copying imports from pioche.config.js");
    // Use es-build to flatten everything
    const contents = fs.readFileSync(path.join(cwd, "piochetemp/pioche.config.mjs"), "utf8");
    // Find the export default statement
    const importreqs = [];
    let start = undefined;
    // Find all import statements
    // Import statements start with "import" and end with ;
    // ; is guaranteed due to esbuild!
    [...contents].forEach((c, i) => {
        if(contents.slice(i, i+6) === "import"){
            start = i;
        }
        if(c === ";" && start !== undefined){
            importreqs.push(contents.slice(start, i+1));
            start = undefined;
        }
    });
    logger.finish();
    // Warn for the use of require statements
    contents.split("\n").forEach((lin) => {
        if(lin.includes(" require("))
            logger.fgerror("Use of require() statements not currently allowed");
    });
    return importreqs;
}

function getDotenv(logger){
    logger.begin("Opening and parsing .env");
    const dotenv = require("dotenv").config().parsed;
    if(!dotenv)
        logger.info("No .env file in directory");
    else{
        logger.finish();
        return dotenv;
    }
}

function createDefaultDotenv(logger) {
    logger.begin("Generating new .env with secure JWT secret");
    const key = crypto.randomBytes(32).toString("hex");
    const contents =
        "# =============================================\n" +
        "# Define environment variables here\n" +
        "# Never commit your .env file\n"+
        "# =============================================\n\n"+
        `JWT_SECRET=${key}`;
    // Write the file
    fs.writeFileSync(path.join(cwd, "/.env"), contents);
    logger.finish();
    return {JWT_SECRET: key};
}

async function discoverControllers(logger){
    logger.begin("Discovering controllers");
    const files = [].concat(
        glob.sync(cwd + "/src/**/*.js", {}),
        glob.sync(cwd + "/src/**/*.cjs", {}),
        glob.sync(cwd + "/src/**/*.mjs", {}),
        glob.sync(cwd + "/src/**/*.jsx", {}),
        glob.sync(cwd + "/src/**/*.ts", {}),
        glob.sync(cwd + "/src/**/*.mts", {}),
        glob.sync(cwd + "/src/**/*.cts", {}),
        glob.sync(cwd + "/src/**/*.tsx", {})
    ).filter((name) => path.basename(name) !== "entry.ts");
    if(!files.length){
        logger.info("No JS or TS files found in ./src (Checked .js/jsx .m/cjs .ts/tsx .m/cts)");
        return;
    }
    logger.finish();
    const controllers = {workers: {}, durable_objects: {}};
    for(const filename of files){
        logger.fgwrite("    > FILE: " + path.basename(filename), "yellow");
        const exports = await getExports(filename, logger);
        for(const [, value] of Object.entries(exports)){
            const importpath = path.relative(path.join(cwd, "src"), filename);
            checkPotentialController(value, (name) => {
                controllers.durable_objects[name] = importpath;
            }, (name) => {
                controllers.workers[name] = importpath;
            });
        }
    }
    return controllers;
}

function checkPotentialController(value, doCallback, workerCallback){
    let proto = value;
    const name = proto.name;
    while(proto.name !== undefined){
        if(proto.name === "DurableObjectController"){
            // Don't care where it comes from as long as it's exported
            doCallback?.(name);
            break;
        }
        if(proto.name === "WorkerController"){
            // Don't care where it comes from as long as it's exported
            workerCallback?.(name);
            break;
        }
        proto = proto.__proto__;
    }
}

function getWranglerToml(logger){
    logger.begin("Opening and parsing wrangler.toml");
    try{
        const tomlRaw = fs.readFileSync(path.join(cwd, "wrangler.toml"), "utf8");
        if(tomlRaw){
            try{
                const wranglerToml = toml.parse(tomlRaw);
                logger.finish();
                return wranglerToml;
            } catch (e) {
                logger.error("Error parsing wrangler.toml on line " + e.line + ", column " +
                e.column + ": " + e.message);
                return -1;
            }
        }
    } catch {
        logger.info("No wrangler.toml found, generating");
        return {};
    }
}

/**
 * Creates an updated wrangler.toml with migrations, bindings, and build command set
 * @param contents Contents of the original wrangler.toml
 * @param config pioche.config config file
 */
async function updateWranglerToml(logger, contents, config, dotenv, controllers, extControllers){
    logger.begin("Generating wrangler.toml");
    const header =
        "# =============================================================================\n" +
        "# Required for workers runtime, never commit this file\n" +
        "# durable_objects, kv_namespaces, migrations, build, and vars autogenerated\n" +
        "# =============================================================================\n\n";
    // Set vars to our .env entries
    contents.vars = dotenv;

    // Set kv_namespaces to our kv_namespaces
    contents.kv_namespaces = [];
    Object.entries(config.kv_namespaces || []).forEach(([binding, id]) => {
        contents.kv_namespaces.push({binding: binding, id: id});
    });

    // Set Durable Object Bindings
    const oldDOs = contents.durable_objects?.bindings.map((e)=>e.name);
    contents.durable_objects = {
        bindings: [
            ...Object.entries(controllers.durable_objects).map(([e]) => e),
            ...extControllers.durable_objects
        ].map((name) => {
            return {
                name: name,
                class_name: name
            };
        }
    )};
    const newDOs = contents.durable_objects?.bindings.map((e)=>e.name);

    // FWD: Migrations compare oldDOs and newDOs
    if(!contents.migrations) contents.migrations = [];

    // Set the build command
    contents.build = {
        command: "npm run build",
        cwd: "./",
        watch_dir: "src"
    };

    // Set the entry point
    contents.main = "src/entry.ts";
    // Set but don't override the name, workers_dev, minify, & compat date
    if(!contents.name) contents.name = path.relative(path.join(cwd, ".."), cwd);
    if(contents.workers_dev === undefined) contents.workers_dev = true;
    if(contents.minify === undefined) contents.minify = true;
    const datestr = (new Date()).toISOString().slice(0, 10);
    if(!contents.compatibility_date) contents.compatibility_date = datestr;
    // Node compat is require
    contents.node_compat = true;

    // Prompt for account_id, allow non-entry
    if(!contents.account_id){
        const readline = require("readline").createInterface({
            input: process.stdin,
            output: process.stdout
        });
        let lockres = undefined;
        const lock = new Promise((resolve)=>{lockres = resolve;});
        readline.question("  > Enter CF account_id or enter to skip: ", aid => {
            if(aid) contents.account_id = aid;
            readline.close();
            lockres();
        });
        await lock;
        logger.fgwrite("\033[1A"); // Move the stdin cursor back up one line
    }

    // Don't write out empty arrays
    if(!contents.kv_namespaces.length) delete contents.kv_namespaces;
    if(!contents.migrations.length) delete contents.migrations;
    if(!contents.durable_objects.bindings.length) delete contents.durable_objects;

    // Write out the new file
    const tomlOutputString = header + toml.stringify(contents);
    fs.writeFileSync(path.join(cwd, "wrangler.toml"), tomlOutputString);
    logger.finish();
}

function generateEntry(logger, config, controllers, extControllers, tbimports){
    logger.begin("Generating entry file");
    let contents = "";
    contents +=
        "// ===================================================\n" +
        "// Created automatically, edits won't have any effect\n" +
        "// ===================================================\n\n" +
        "import { DefaultHandlers, Router } from \"pioche\";\n\n";
    
    
    // Bring in imports from pioche.config
    if(tbimports.length){
        contents += "// The following were brought in from pioche.config.ts/js\n" +
            tbimports.join("\n").replaceAll("src/", "") + "\n\n";
    }

    // Use our compiled controller list to bring in local controllers
    contents += "// Import all discovered controllers\n" + [
        ...Object.entries(controllers.workers),
        ...Object.entries(controllers.durable_objects)
    ].map(([name, loc]) => {
        const extlen = path.extname(loc).length;
        return `import { ${name} } from "./${loc.slice(0, loc.length - extlen)}"`;
    }).join(";\n") + ";\n\n";

    // List all controllers to avoid tree shaking
    contents += "// Listing controllers prevents them from being tree-shaken\n" + [
        ...Object.entries(controllers.workers).map(([n])=>n),
        ...Object.entries(controllers.durable_objects).map(([n])=>n),
        ...extControllers.workers,
        ...extControllers.durable_objects
    ].join(";\n") + ";\n\n";

    // Router.useBefore all of the prehandlers
    if(config.prehandlers.length){
        contents += "// Add all configged prehandlers to the Router\n" + 
        config.prehandlers?.map(
            (ph) => `Router.useBefore(${ph.name})`
        ).join(";\n") + ";\n\n";
    }
    
    // Router.useAfter all of the posthandlers
    if(config.posthandlers.length){
        contents += "// Add all configged postHandlers to the Router\n" + 
        config.posthandlers.map(
            (ph) => `Router.useAfter(${ph.name})`
        ).join(";\n") + ";\n\n";
    }

    contents += "export default DefaultHandlers;\n";
    // Write the file
    fs.writeFileSync(path.join(cwd, "src/entry.ts"), contents);
    logger.finish();
}

async function getExports(filename, logger){
    let exports;
    // If ts we'll need to transpile it before checking for exports
    if([".ts", ".cts", ".mts", ".tsx"].includes(path.extname(filename))){
        logger.fgwrite(" > transpiling", "yellow");
        esbuild.buildSync({
            entryPoints: [filename],
            outfile: path.join(cwd, "piochetemp/temp.mjs"),
            logLevel: "silent",
            format: "esm"
        });
    }
    try{
        // Try to import it as a module
        // This will succeed on .mjs, .js/.jsx ES6 modules, and .ts/.tsx/.cts/.mts
        logger.fgwrite(" > importing as ES6", "yellow");
        exports = await import(path.join(cwd, "piochetemp/temp.mjs"));
        logger.fglog(" > success", "green");
    } catch (e) {
        logger.fglog(" > failed", "red");
        try{
            // Try to require it
            // This will succeed on .js/.jsx CJS modules
            logger.fgwrite(" > importing as CJS", "yellow");
            exports = require(path.join(cwd, "piochetemp/temp.mjs"));
            logger.fglog(" > success", "green");
        } catch (e1) {
            console.log(e);
            logger.fglog(" > failed", "red");
        }
    }
    return exports;
}